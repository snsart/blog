在构建大型程序的时候，为了方便代码管理，会根据不同的功能把代码分为多个片段（或模块）并存储在不同的文件中，在代码执行时需要把这些代码模块合并成一个单一的可执行文件，这个合并过程称之为链接。接下来我们先汇总一下链接过程会遇到哪些问题，再逐个分析每个问题是如何解决的。

提纲：
1. 从源代码到可执行目标文件
2. 可重定位目标文件
3. 可执行目标文件
4. 链接过程——从可重定位目标文件到可执行目标文件
4.1 符号解析
4.2 重定位
5. 举例

一、从源代码到可执行目标文件
GCC编译C源码有四个步骤：
预处理——> 编译——> 汇编 ——> 链接
1. 预处理阶段，预处理器将C源代码包含的头文件编译进来，形成预处理文件。
2. 编译阶段，在这个阶段编译器会检查代码的规范性,是否有语法错误等，在确定无误后，编译器把代码翻译成汇编语言。
3. 汇编阶段，汇编器把在编译阶段生成的汇编语言转成二级制目标代码，分为可重定位目标文件，可执行目标代码和可共享目标代码。
4. 链接阶段，链接器把多个可重定位目标文件链接成最终可执行的目标文件。
本文分析了链接阶段的详细过程；

二、可重定位目标文件

代码模块在编译之后会形成可重定位目标文件，文件中存储的代码为二进制格式，但是这些代码是不能载入内存中运行的，原因有二：
a. 可能确少入口函数，在C语言中，入口函数为main；
b. 引用的一些符号（全局变量或函数）缺乏定义，这些符号的定义存在其他模块文件中；
为了形成可执行的文件，此文件需要和其他模块编译后产生的目标文件链接在一起，为了方便链接，可重定位目标文件中除了基本的程序指令和程序数据之外，还有其它重要的数据结构来描述文件，比如符号表。可重定位目标文件分为多个节，主要的节段如下；

1. 代码和数据
.text节：存储所有指令和常量，编译器对指令中的未知符号，会生成对应的重定位条目；
.data节: 存储所有已被初始化的全局变量、静态变量；
.bss节：存储所有未被初始化或初始化为0的全局变量和静态变量；

.UNDEF：未定义符号，表明被这个目标文件引用，但是在其他地方定义
.COMMON：表示还未分配位置的未初始化的数据目标
.ABS：不该被重定位的符号

2. 符号表
符号表用来描述程序代码和程序数据中存储的指令和数据，其中的符号包含如下几类：
1) 在本模块定义，但是可被其他模块引用的符号，包括函数，全局变量和静态变量；
2) 在本模块引用，但是在其他模块中定义的符号；
3) 只被本模块定义和引用的本地符号。带static的函数和带static的全局变量和本地变量；

每一条符号描述的数据结构如下：
```
typedef struct{
	int 	name;
	char 	type:4,
			binding:4;
	char	reserved;
	short	section;
	long	value;
	long	size;
}ELF64_Symbol;
```
符号表中的条目主要描述了符号定义的如下特征：符号类型,即函数还是变量(type)，作用域，即全局还是局部(binding),符号定义所在的节(section)，符号定义在节中的偏移量(value),符号定义所占空间的大小，连接器正是通过这些信息对指令和数据进行重定位。

3. rel.text和rel.data
.rel.text: 一个.text节中位置的列表。当链接器将此文件与其他目标文件链接时需要修改这些位置，一般任何调用外部函数或引用全局变量的指令都要修改
.rel.data: 引用或定义的任何全局变量的重定位信息，任何已初始化的全局变量，如果它的初值是一个全局变量地址或外部函数地址，就需要修改
链接器通过这两个字段的条目计算符号引用的地址，重定位时会修改这两个节段的值。其中条目的数据结构如下：
```
typedef struct{
	long offset;
	long type:32
			
}ELF64_Rela;
```

三、可执行目标文件
可执行目标文件可加载到内存中运行，其程序代码和数据中的符号都已经定位到对应的虚拟内存空间。由于没有未定义的符号和未初始化的数据目标，所以UNDEF、COMMON和ABS节段是不存在的。可执行目标文件结构如下：


四、链接过程——符号解析
由于多个模块中可能存在对同一符号的重复定义，通过符号解析过程，可以确保每一个符号有且只有一个定义，并且符号表中对没个定义只存在唯一的符号解析。我们把已经初始化或初始化为0的符号称之为强类型，未初始化的符号称之为弱类型，符号解析规则如下：
1. 同一个符号不能存在两个及两个以上的强类型，否则抛出错误；
2. 同一个符号如果存在1个强类型和多个若类型，那么选择强类型；
3. 同一个符号如果存在多个若类型，则随机选择一个；
符号解析时，链接器会创建3个空的列表，分别存储未定义的符号(假设为A)，已定义的强类型符号(假设为B)以及符号定义(假设为C),初始状态三个容器都为空，接下来链接器会依次遍历重定位文件的符号列表，当发现未定义的符号时，将其加入A中，...，当遍历结束之后，发现A不为空时，说明有未定义的符号，抛出错误；
符号解析完成后，B中的符号解析和C中的符号定义会呈现一对一对应关系；

五、链接过程——重定位
1. 重定位全局变量
符号解析完成后，由于容器B中的每一个符号解析都有对应的唯一的定义，由于通过符号解析能找到符号定义的大小和位置，所以可以依次把定义的符号按不同的字段聚合在一起，并能够重新定位聚合后符号的虚拟内存位置及其更新符号表及rel.text和rel.data表。
从定位过程举例：



2. 重定位引用符号
根据rel.text结构的值可以计算出引用符号的地址





<body class="body">
		<div class="margin-auto">
			<div class="demon_Btn">
				<span class="title-pre fl"></span>
				<div class="title-text fl">
					<span class="head-txt">演示程序</span>
				</div>
				<span class="title-end fl"></span>
			</div>
		
			<div class="animaContrl" style="border: none; display: none;">
				<ul class="canvas-contrl fr">
					<li class="arrow btn"></li>
					<li class="hand btn"></li>
					<li class="enlarge btn"></li>
					<li class="reduce btn"></li>
					<li class="initbtn btn"></li>
				</ul>
				<canvas id="canvas" width="1024" height="768" style="width:40rem;"></canvas>
			</div>
		</div>
		<script src="js/h5_loader_primary_math.js" type="text/javascript" charset="utf-8"></script>
		<script src="js/h5_init_primary_math.js" type="text/javascript" charset="utf-8"></script>
	</body>




























一、链接会遇到的问题

1. 链接之后形成的文件格式
需要知道链接的方向，知道可执行文件要具备哪些特点；
2. 链接所需的文件格式
链接合并的是源文件编译之后形成的可重定位目标文件，这个文件的格式需要具备哪些特点；
3. 什么时候开始链接
编译时、加载时还是运行时
4. 命名冲突问题
在可执行文件中必须保证每个符号定义都是唯一的（局部变量除外），而被合并的多个文件中可能存在多个相同的符号定义；
5. 内存地址分配问题，在可执行文件中代码和每个数据都需要有唯一的地址，在被合并的多个文件中代码和数据的地址和可执行文件中是不一样的，该如何调整；
6. 如何根据引用的符号查找符号的定义。



二、链接的方向：可执行目标代码的特点

代码编译并链接之后形成的文件称之为可执行目标文件，当文件载入内存中时，代码在内存中分为如下字段：

从图中可知，可执行目标文件要能够正确的载入内存，系统必须能够明确的区分文件中涉及的符号类型，并能够通过符号找到唯一的内存地址。在可执行目标文件中专门有一个符号表来管理文件中的符号，符号表中的符号分为下面几类：
1). 代码，比如函数名，它代表了一段指令的集合
2). 已初始化数据，包括全局变量和静态变量
3). 未初始化数据，包括全局变量和静态变量
上面每一个符号，对应着一个唯一的定义，不同类型符号的定义存在文件的不同节中，代码存在.text节，已初始化的数据存在.data节，未初始化的数据或初始化为0的数据存在.BSS节。加载器将可执行目标文件载入内存中时，会通过查找符号表，把.text节中对应的符号替换为相应的值；

可执行目标文件总结如下：
1. 符号表中的符号是唯一的；
2. 符号表中的每个符号都有唯一的地址，并且通过符号能找到对应的定义；

三、链接的起点：可重定位目标文件的特点
源代码通过编译器编译之后会形成可重定位目标文件，连接器

程序代码和程序数据
