## [<<目录](https://github.com/snsart/blog/blob/master/README.md)

## AMD：异步模块模式
在浏览器中对文件的加载是异步，因此要使用未加载的模块中的某些模块方法时，会经历加载过程。下面是AMD的实现过程：

### setModule方法：
setModule方法负责创建模块，在创建setModule方法时，分为两种情况考虑
1. 此模块是需要被别的模块（下面称父模块）使用的模块，即此模块属于具名模块，它的唯一标识符为模块的路径；
2. 此模块是匿名模块，一般在程序入口直接使用，不需要被其他模块调用；
针对第一种情况，父模块在使用此模块时，会判断此模块是否被加载（判断缓存是否存在），若没加载程序会创建此模块的一个缓存moduleCache[moduleName]对象，并为缓存中的对象添加status，exports及onload属性。其中status标识模块加载状态，初始为loading；exports存储此模块的回调函数中返回的模块对象，初始为null；onload存储此模块加载完成后触发的回调函数。判断此模块是否加载完成的标志是此模块中的代码是否开始运行，即当setModule开始执行的时候，意味着此模块一定加载完成了，此时会将模块status设置为loaded，exports设置为回调函数返回的对象，然后运行onload中存储的回调函数，回调函数中的参数_module.exports作为父模块使用的一个参数，即存储在父模块的params中；代码如下：
```javascript
setModule=function(moduleName,params,callback){
	var _module,fn;
	if(moduleCache[moduleName]){
		_module=moduleCache[moduleName];
		_module.status='loaded';
		_module.exports=callback?callback.apply(_module,params):null;
		while(fn=_module.onload.shift()){
			fn(_module.exports);//当前模块加载完成执行fn回调函数;
		}
	}else{
		callback&&callback.apply(null,params);
	}
}
```

### loadModule方法：
loadModule方法用来加载模块，并为加载的模块设置回调函数，此方法会首先查找缓存中是否存在要加载的模块，若存在，则判断模块的加载状态，若已加载完成则执行回调函数，否则把回调函数加入模块的onload中。若缓存中不存在此模块，则为缓存创建一个，并设置status、exports及onload等属性，然后开始加载此模块(loadScript函数)，当模块加载完成后会修改这些属性，看setModule函数。
```javascript
loadModule=function(moduleName,callback){
	var _module;
	if(moduleCache[moduleName]){
		_module=moduleCache[moduleName];
		if(_module.status==='loaded'){
			setTimeout(callback(_module.exports),0);
		}else{
			_module.onload.push(callback);
		}
	}else{
		moduleCache[moduleName]={
			moduleName:moduleName,
			status:'loading',
			exports:null,//此模块的入口函数，即创建此模块时，回调函数中返回的对象。
			onload:[callback]
		};
		loadScript(getURL(moduleName));
	}
};
```

### 创建模块
上面是两个主要的工具，接下来是创建模块的入口：
```javascript
F.module=function(url,modDeps,modCallback){
	var args=[].slice.call(arguments),
		callback=args.pop(),
		deps=(args.length&&args[args.length-1] instanceof Array)?args.pop():[],
		url=args.length?args.pop():null,
		params=[],
		depsCount=0,
		i=0,
		len;
	if(len=deps.length){
		while(i<len){
			(function(i){
				depsCount++;
				loadModule(deps[i],function(mod){
					params[i]=mod;
					depsCount--;//每加载完成一个依赖模块depsCount减1
					if(depsCount===0){
						setModule(url,params,callback);	//当此模块依赖的模块全部加载完成时，运行此模块的setModule;
					}
				});
			})(i);
			i++;
		}
	}else{
		setModule(url,[],callback);//若此模块没有依赖模块则直接运行setModule;
	}
}
```
通过F.module函数，重述一遍理解AMD的关键点：由于F.module函数是放在每一个需要加载的模块文件当中的，比如dom.js文件中定义F.module("dom",function(){//...})，因此当F.module函数开始运行时，意味着此模块文件（比如dom.js）必然加载完成，若此模块没有依赖模块则直接执行setModule函数，否则加载其他依赖模块后执行setModule函数，即当程序执行setModule函数时，意味着此模块及其依赖模块全部加载完成。下面是完整的实现，为了屏蔽loadModule等工具函数，创建了一个闭包：

### 完整代码
```javascript
(function(F){
	var moduleCache={},
		setModule=function(moduleName,params,callback){
			var _module,fn;
			if(moduleCache[moduleName]){
				_module=moduleCache[moduleName];
				_module.status='loaded';
				_module.exports=callback?callback.apply(_module,params):null;
				while(fn=_module.onload.shift()){
					fn(_module.exports);
				}
			}else{
				callback&&callback.apply(null,params);
			}
		},
		getURL=function(moduleName){
			return String(moduleName).replace(/\.js$/g,'')+'.js';
		},
		loadScript=function(src){
			var _script=document.createElement('script');
			_script.type='text/javascript';
			_script.charset='UTF-8';
			_script.async=true;
			_script.src=src;
			document.getElementsByTagName('head')[0].appendChild(_script);
		},
		loadModule=function(moduleName,callback){
			var _module;
			if(moduleCache[moduleName]){
				_module=moduleCache[moduleName];
				if(_module.status==='loaded'){
					setTimeout(callback(_module.exports),0);
				}else{
					_module.onload.push(callback);
				}
			}else{
				moduleCache[moduleName]={
					moduleName:moduleName,
					status:'loading',
					exports:null,//此模块的入口函数，即创建此模块时，回调函数中返回的对象。
					onload:[callback]
				};
				loadScript(getURL(moduleName));
			}
		};
		
	F.module=function(url,modDeps,modCallback){
		var args=[].slice.call(arguments),
			callback=args.pop(),
			deps=(args.length&&args[args.length-1] instanceof Array)?args.pop():[],
			url=args.length?args.pop():null,
			params=[],
			depsCount=0,
			i=0,
			len;
		if(len=deps.length){
			while(i<len){
				(function(i){
					depsCount++;
					loadModule(deps[i],function(mod){
						params[i]=mod;
						depsCount--;
						if(depsCount===0){
							setModule(url,params,callback);	
						}
					});
				})(i);
				i++;
			}
		}else{
			setModule(url,[],callback);
		}
	}
})(
	window.F={}
)
```

### 个人思维误区
我们如何知道文件是否加载完成，当文件加载完成时，如何通知回调函数开始执行，一开始自己一直以为需要事件机制，即加载文件时需要注册一个onload事件，当完成时通知回调函数执行。但在阅读代码时，并没有看到这样的事件，因此对AMD百思不得其解，后来查阅了很多资料，看到的一句话终于使一切迎刃而解：文件中代码开始执行意味着文件加载完成。因此只需要在加载的文件中执行回调函数即可。