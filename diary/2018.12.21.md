## [<<目录](https://github.com/snsart/blog/blob/master/README.md)

## 代理模式Proxy
当一个对象（或模块）无法直接与另一个对象（或模块）进行直接交互，或不适合与另一个对象交互时，我们可以通过创建其中一个对象的代理，让另一个对象和这个代理进行交互。代理对象和被代理对象（委托对象）提供的功能是一样的。

### 组成
1. 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。
2. 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
3. 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。

### 主要解决
在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

![代理模式示意图](https://github.com/snsart/blog/blob/master/diary/images/2018122101.jpg);

### 前端应用举例
1. 当页面的资源图片比较大需要较长时间加载时，可以先加载原图的一个代理图片，等原图加载完成再显示原图；
2. 解决跨域问题:由于javascript的同源策略限制，js是不能访问不同域名下的资源的。但通过script或img的src属性是可以请求不同域的资源的，虽然这种访问是get请求，但为我们跨域访问提供了一扇窗口。我们可以借助一些技巧，通过在src的url中写入一些数据，配合服务端，完成数据的通信。这里url就是页面跟跨域服务端进行交互的代理；

### 代理模式与外观模式的区别
外观模式是综合封装了一系列对象或子系统的方法，形成了一个统一的易用的接口，是为了解决子系统难以使用的问题。而代理是创建了一个对象的替身，替身提供的接口和对象是一样的，代理解决的是两个对象不宜直接交互的问题。