## [<<目录](https://github.com/snsart/blog/blob/master/README.md)

## 函数柯里化
函数柯里化是一种函数式编程技巧，通过这种技巧可以让函数分步骤处理参数，即让函数先处理一部分参数，再处理剩余的参数。好比厨师做饭：既可以把所有食材都准备好再做，也可以先准备一部分，在做的过程中再准备其他食材。换言之，函数柯里化是把一个函数处理多个参数转化为了多个函数依次处理单个（或少量几个）参数 。下例展示了函数柯里化的概念：
```
function add(num1,num2){
	return num1+num2;
}

function curriedAdd(num2){
	return add(5,num2);
}
```
函数curriedAdd只接受一个参数，它本质上是在任何情况下第一个参数为5的add()版本。

### 柯里化函数
柯里化函数把一个函数A和函数A的部分参数作为参数，返回另一个函数B，函数B把函数A的剩余参数作为参数进行求解。实现如下：
```
function curry(fn){
	var args=Array.prototype.slice.call(arguments,1);
	return function(){
		var innerArgs=Array.prototype.slice.call(arguments);
		var finalArgs=args.concat(innerArgs);
		return fn.apply(null,finalArgs);
	}
}
```
carry()函数可以按以下方式应用:
```
var curriedAdd=curry(add,5);
alert(curriedAdd(3));//8,相当于add(5,3);
```


函数柯里化可以构造更为复杂的bind()函数：例如:
```
function bind(fn，context){
	var args=Array.prototype.slice.call(arguments,2);
	return function(){
		var innerArgs=Array.prototype.slice.call(arguments);
		var finalArgs=args.concat(innerArgs);
		return fn.apply(context,finalArgs);
	}
}
```

### 应用场景
1. 多用于一个函数要以指针的形式进行传递，并且传递的函数需要一些参数，比如事件处理程序以及setTimeout()和setInterval()。
2. 因为js不存在函数级别的静态变量(c语言中的概念)，无法在函数重入的时候保存之前的状态。运用函数柯里化可以做一个可重入的方法(可以设置个初始值，之后函数返回的结果基于这个初始值变化)