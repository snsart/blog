## [<<目录](https://github.com/snsart/blog/blob/master/README.md)

## 等待者模式
当有多个异步任务在执行的时候，等待者模式可以帮助我们监控所有任务是否全部完成，并在所有任务完成时立即执行一些行为。
### 设计思路
等待者模式会为每个任务创建一个监控对象，并由一个等待者（waiter）来管理所有的监控对象。当某个任务完成（或执行失败）时，相对应的监控对象的状态将发生改变，并执行解决成功或解决失败的函数，这两个函数会通过其他监控对象的状态来判断所有任务是否完成并执行向对应的动作。

### 实现
1. 首先设计一个等待者，主要有三个作用：
（1）创建和管理监控对象<br>
（2）添加和管理所有任务完成后的回调函数<br>
（3）添加和管理任务失败（只要有一个任务失败则意味着任务失败）后的回调函数<br>
```
var Waiter=function(){
	var dfd=[],//监控对象容器
		doneArr=[],//执行成功回调函数容器
		failArr=[],//执行失败回调函数容器
		slice=Array.prototype.slice,//多次用到的方法进行缓存将提高性能
		that=this;
		var Primise=function(){
			this.resolved=false;
			this.rejected=false;
		}
		Primise.prototype={
			resolve:function(){
				this.resolved=true;
				if(!dfd.length){
					return;
				}
				//遍历所有注册了的监控对象判断任务是否完成
				for(var i=dfd.length-1;i>=0;i++){
					if(dfd[i]&&!dfd[i].resolved||dfd[i].rejected){
						return;
					}
					dfd.splice(i,1);
				}
				//执行任务完成的回调函数
				_exec(doneArr);
			},
			reject:function(){
				this.rejected=true;
				if(!dfd.length){
					return;
				}
				dfd.splice(0);
				_exec(failArr);
			}
		}
		
		//创建监控对象
		that.Deferred=function(){
			return new Primise();
		}
		//执行回调函数方法
		function _exec(arr){
			var i=0,len=arr.length;
			for(;i<len;i++){
				try{
					arr[i]&&arr[i]();
				}catch(e){}
			}	
		};
		
		
		//添加监控对象，参数：监控对象
		that.when=function(){
			dfd=slice.call(arguments);
			var i=dfd.length;
			for(--i;i>=0;i--){
				if(!dfd[i]||dfd[i].resolved||dfd[i].rejected||!dfd[i]instanceof Primise){
					dfd.splice(i,1);
				}
			}
			return that;
		};
		
		
		//添加所有任务完成后的回调函数，参数：函数
		that.done=function(){
			doneArr=doneArr.concat(slice.call(arguments));
			return that;
		};
		
		//添加任务失败后的回调函数，参数：函数
		that.fail=function(){
			failArr=failArr.concat(slice.call(arguments));
			return that;
		}
}
```

### 应用示例
下面通过两个setTimeout函数启动两个异步任务，并为每一个配置一个监控对象：
```
var waiter=new Waiter();
var dtd1=waiter.Deferred();
setTimeout(function(){
	console.log("任务1完成");
	dtd1.resolve();
},5000)

var dtd2=waiter.Deferred();
setTimeout(function(){
	console.log("任务2完成");
	dtd2.resolve();
},6000)

waiter.when(dtd1,dtd2).done(function(){
	console.log("所有任务完成");
}).fail(function(){
	console.log("任务失败");
})


```

等待者模式意在处理比较耗时的操作，比如定时器、异步请求、图像处理等。