## [<<目录](https://github.com/snsart/blog/blob/master/README.md)

## npm
NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：
* 允许用户从NPM服务器下载别人编写的第三方包到本地使用。
* 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。
* 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用

### 下面是一些常用命令
#### 查看npm版本
```
npm -v
```
#### 升级npm
```
npm install npm -g 
```
#### 安装模块
* 本地安装
```
npm install <Module Name>
```
安装好之后，<Module Name>包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(<Module Name>) 的方式就好，无需指定第三方包路径。

* 全局安装
```
npm install <Module Name> -g
```
1. 将安装包放在 /usr/local 下或者你 node 的安装目录。
2. 可以直接在命令行里使用。

#### 卸载模块
```
npm uninstall <Module Name>
```

#### 更新模块
```
npm update <Module Name>
```

#### 其他命令，
npm提供了很多命令，例如install和publish，使用npm help可查看所有命令。

<br>
## webpack
项目代码编写完成，在上线之前还需要做一件事情——打包

### 为什么要打包
软件开发的典型模式是写代码-编译-测试，即首先写好代码，将其编译通过，然后运行并确保其正常工作。由于JavaScript并非一个编译型语言，模式变成了写代码-测试，这里你写的代码就是你要在浏览器中测试的代码。这个方法的问题在于它不是最优的，你写的代码不应该原封不动地放入浏览器中，理由如下所示。
1. 知识产权问题——如果把带有完整注释的代码放到线上，那别人就更容易知道你的意图，对它再利用，并且可能找到安全漏洞。
2. 文件大小——书写代码要保证容易阅读，才能更好维护，但是这对于性能是不利的。浏览器并不能从额外的空白字符或者是冗长的函数名和变量名中获得什么好处。
3. 代码组织——组织代码要考虑到的可维护性并不一定是传送给浏览器的最好方式。<br>

基于这些原因，最好给JavaScript文件定义一个构建过程。webback就是解决这些问题的一款流行的构建工具。

### webpack
Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。
![webpack功能演示图](https://github.com/snsart/blog/blob/master/diary/images/2018122601.png);

#### 安装 Webpack
```
npm install webpack -g
```

#### 构建命令举例
```
webpack runcoob1.js bundle.js
```
这个命令会把runcoob1.js及runcoob1.js依赖的其他文件资源打包成一个文件bundle.js;<br>
webpack 根据模块的依赖关系进行静态分析，这些文件(模块)会被包含到 bundle.js 文件中。Webpack 会给每个模块分配一个唯一的id并通过这个id索引和访问模块。 在页面启动时，会先执行 runoob1.js 中的代码，其它模块会在运行require 的时候再执行。

#### 打包非js模块
webpack本身只能处理JavaScript模块，如果要处理其他类型的文件，就需要使用loader进行转换。比如要添加css文件，就要使用css-loader和style-loader，安装命令如下：
```
cnpm install css-loader style-loader
```
具体使用方法参考：[http://www.runoob.com/w3cnote/webpack-tutorial.html](http://www.runoob.com/w3cnote/webpack-tutorial.html)

#### 配置文件
* 可以通过配置文件统一管理
创建 webpack.config.js 文件，代码如下所示：
```
module.exports = {
    entry: "./runoob1.js",
    output: {
        path: __dirname,
        filename: "bundle.js"
    },
    module: {
        loaders: [
            { test: /\.css$/, loader: "style-loader!css-loader" }
        ]
    }
};
```
接下来只需要执行 webpack命令即可生成 bundle.js 文件，webpack 命令执行后，会默认载入当前目录的 webpack.config.js 文件。

## npm全局安装和本地安装的区别
### 全局安装
全局安装的包安装在Node安装目录下的node_modules文件夹中，一般在 \Users\用户名\AppData\Roaming\ 目录下。可以使用npm root -g查看全局安装目录。全局安装后可以供命令行使用，用户可以在命令行中直接运行该组件包支持的命令。
### 本地安装
npm install package-name || npm install package-name --save -dev  --save-dev的含义是代表把你的安装包信息写入package.json文件的devDependencies字段中，本地安装的包安装在指定项目的node_modules文件夹下。本地安装后可以直接通过require()的方式引入项目中node_modules目录下的模块。一般安装在全局的都是有命令行需求的 package，但是具体项目中的包需要本地安装。

### 为什么需要本地安装
1.在js实例代码中，默认下node.js会在NODE_PATH和目前js所在项目下的node_modules文件夹下去寻找模块，因此，如果只是全局安装，不能直接通过require()的方式去引用模块，需要手动解决包路径的配置问题，当然也可以复制全局安装的node_modules文件夹到项目下
2.对于包的更新不好管理，可能你需要为每个包重新命名，如gulp@3.8.1、gulp@3.9.1...，为了区别不同项目使用指定的包，保证模块之间的相互依赖（这块下面会介绍），区别每个项目正常运行。
因此，不推荐只全局安装。

### 本地安装的重要性
1. 最早的node.js/npm实际上是全局的，包括现在还兼容NODE_PATH，但是不能支持全局多版本，于是nodejs团队改成本地安装的方法可能就是为了保证不同版本包之间的相互依赖。一个项目依赖的模块的版本不可轻易修改，本地安装保证了不同项目相同模块的版本无须一致。
2. 本地安装可以让每个项目拥有独立的包，不受全局包的影响，方便项目的移动、复制、打包等，保证不同版本包之间的相互依赖，这些优点是全局安装难以做到的。
3. 据node团队介绍，本地安装包对于项目的加载会更快。<br>

有优点也少不了缺点，如每次新项目都要本地安装所依赖的包，安装包时间相对较长，一来是包太大导致下载慢；二是浪费了硬盘空间，不过现在电脑硬盘动不动就几个T，你还会在意节省这点空间吗？