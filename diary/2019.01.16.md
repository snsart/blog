## [<<目录](https://github.com/snsart/blog/blob/master/README.md)

## Widget
Widget模式是指借用WebWidget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。
### 比较
若不用widget开发页面部件：直接在html文件中写部件的html代码，若多个页面中有相同的组件，则需复制代码到多个文件中。<br>
使用widget:只需要编写一套模板和数据，通过模板方法创建一个组件，借助AMD，把组件放在一个文件中，可以实现组件的复用。<br>
与简单模板的区别：简单模板模式只是字符串的简单替换，而widget可以编译js代码，从而创建更复杂的组件，比如通过for循环创建列表。<br>

### 实现过程

#### 处理模板
编写模板时为了区分js和html代码，把js代码放入{%//需运行的js代码 %}之中，把需要替换的变量放入{%=  %}之中，在处理模板时要把{% %}之外的代码，即html代码放入templay_array数组中，最后把数组转换为字符串即可。下面是一个转换实例：</br>
给定一个模板字符串如下：
```
<div id="tag_cloud">
{% for(var i=0,len=tagCloud.length;i<len;i++){
		var ctx=tagCloud[i];%}
		<a href="#" class="tag_item {% if(ctx['is_selected']){ %} selected {% } %} "  title="{%= ctx["title"] %}">{%= ctx["text"] %}</a>
	{% } %} 
</div>

```

需要把上面的模板字符串转换为如下的代码：
```
templay_array.push('<div id="tag_cloud">');
for(var i=0,len=tagCloud.length;i<len;i++){
	var ctx=tagCloud[i];
	templay_array.push('<a href="#" class="tag_item'); 
	if(ctx['islelected']){
		templay_array.push('selected'); 
	}
	templay_array.push('" title="',typeof(ctx["title"])?"":ctx["title"],'">',typeof(ctx["text"])?"":ctx["text"],'</a>'); 
}
templay_array.push('</div>');
```
主要转化规则如下：
1. 把【{%= ctx["title"] %}】替换为【',typeof(ctx["title"])?"":ctx["title"],'】
这里ctx["title"]可被替换为任何字符串，需要用正则表达式识别模式，再替换。
2. 把【{%】 替换为【');】
3. 把【%}】 替换为【 templay_array.push('】
4. 其他符号的替换

处理模板方法如下：
```
_dealTpl=function(str){
	var _left='{%',
		_right='%}';
	return String(str)
			.replace(/&lt;/g,'<')
			.replace(/&gt;/g,'>')
			.replace(/[\r\t\n]/g,'')
			.replace(new RegExp(_left+'=(.*?)'+_right,'g'),"',typeof(ctx["title"])?"":ctx["title"],'")
			.replace(new RegExp(_left,'g'),"');")
			.replace(new RegExp(_left,'g'),"templay_array.push('");
}

```
#### 编译执行
运用模板和数据形成最终的html代码：编译的函数体首先处理数据，把数据转换为变量，然后运行_dealTpl方法得到的代码，在这个过程中变量的值会自动替换掉_dealTpl得到的代码中的值。从而实现了数据和模板的结合，下面是编译函数体：
```
var fnBody="
var template_array=[];\n
var fn=(function(data){\n
	var template_key='';\n
	for(key in data){\n
		template_key+=('var'+key+'=data[\"'+key+'\"];');\n
	}\n
	eval(template_key);\n
	template_array.push('"+_dealTpl(str)+"');\n
	template_key=null;\n
})(templateData);\n
fn=null;\n
return template_array.join('');\n
";
```

编译函数如下：
```
_compileTpl=function(str){
	var fnBody="var template_array=[];\nvar fn=(function(data){\nvar template_key='';\nfor(key in data){\ntemplate_key+=('var'+key+'=data[\"'+key+'\"];');\n}\neval(template_key);\ntemplate_array.push('"+_dealTpl(str)+"');\ntemplate_key=null;\n})(templateData);\nfn=null;\nreturn template_array.join('');\n";
	return new Function("templateData",fnBody);
}
```

#### 封装接口
下面方法可以根据模板容器id或字符串编译
```
_getTpl=function(str){
	var ele=document.getElementById(str);
	if(ele){
		var html=/^(textarea|input)$/i.test(ele.nodeName)?ele.value:ele.innerHTML;
		return _compileTpl(html);
	}else{
		return _compileTpl(str);
	}

}
```
传入的数据也可能是数组格式，程序也要进行区分处理：
```
_TplEngine=function(str,data){
	if(data instanceof Array){
		var html='',
			i=0,
			len=data.length;
		for(;i<len;i++){
			html+=_getTpl(str)(data[i]);
		}
		return html;
	}else{
		return _getTpl(str)(data);
	}
}
```

### 封装成模块
```
F.module('lib/template',function(){
	var _TplEngine=function(){},
		_getTpl=function(){},
		_dealTpl=function(){},
		_compileTpl=function(){};
	return _TplEngine;
})
```